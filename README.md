# Mica: Automated Property-Based Testing for OCaml Modules 

NB: This branch contains some **experimental** code pertaining to making Mica work with a
module signature for the Diffie-Hellman key exchange protocol. There may be breaking changes
in this repo. Please refer to the **main** branch if you wish to use Mica. 

This repo contains the implementation for **Mica**, a tool which parses any generic OCaml module signature, 
and checks whether two modules implementing the signature are observationally 
equivalent by generating random sequences of commands using Core.QuickCheck.

Documentation (generated with Odoc) located at:      
https://ngernest.github.io/module_pbt/module_pbt/index.html

## Description of source files
- `lib/Parser.ml`: parser utility functions, modified from the Angstrom parser-combinator library
- `lib/ParserTypes.ml`: Datatypes defining an AST for module signatures
- `lib/ModuleParser.ml`: Parser for OCaml module signatures
- `lib/CodeGenerator.ml`: Takes a parsed AST representing a module signature and generates the appropriate PBT code 
- `lib/CmdLineParser.ml`: Parses user input from the command line
- `bin/main.ml`: Entry point for the executable for Mica

## Examples 
**NB: this section is outdated and needs to be updated**

The `lib` directory also contains examples of the test harness adapted to work with the following modules:
- Finite sets (`lib/sets` subdirectory)
  - Signature: `SetInterface.ml`
  - Implementation using lists: `ListSet.ml` (adapted from Yale-NUS YSC2229 website)
  - Implementation using BSTs: `BSTSet.ml` (adapted from Penn CIS 1200 lecture notes)
  - PBT files automatically generated by Mica:      
  `lib/GeneratedSetPBTCode.ml` & `bin/GeneratedSetExecutable.ml`
- Stacks (`lib/stacks` subdirectory)
  - Signature: `StackInterface.ml`
  - Implementation using lists: `ListStack.ml` (adapted from Jane Street's Base library)
  - Implementation using custom ADTs: `VariantStack.ml` (adapted from Cornell CS 3110 textbook)
- Polynomials (`lib/polynomials` subdirectory)
  - Signature: `PolyInterface.ml`
  - Implementation using lists of tuples: `Poly1.ml` (adapted from Jean-Christophe Filliatre)
  - Implementation using lists of records: `Poly2.ml` (adapted from Shayne Fletcher)
- [Elliptic-Curve Diffie-Hellman](https://en.wikipedia.org/wiki/Elliptic-curve_Diffieâ€“Hellman) 
  using [Curve25519](https://en.wikipedia.org/wiki/Curve25519) (`x25519` directory)
  - Signature: `x25519/ECDHIntf.ml`
  - Implementation in OCaml: `x25519/ECDH_OCaml.ml` (adapted from [Markus Rudy](https://github.com/burgerdev))
  - Implementation using the OCaml C FFI: `x25519/ECDH_C.ml` (adapted from [Romain Calascibetta](https://blog.osau.re/index.html))
  - To run this example, we need to specify the `-library` flag as follows:
  ```
  dune exec -- bin/main.exe ./x25519/ECDHIntf.mli ./x25519/ECDH_OCaml.ml ./x25519/ECDH_C.ml -library x25519_ecdh
  ```
  (this example is registered as a separate library in Dune due to the C dependencies)

## Building & running
Run `make` (or `dune build`) to build and compile the library.         
Run `make install` to install dependencies. 

**Usage**:       
`dune exec -- bin/main.exe [.ml file containing signature] [.ml file containing 1st module] [.ml file containing 2nd module]`
- This command runs Mica and creates two new files:
  1. `lib/Generated.ml` (contains PBT code for testing an OCaml module)
  2. `bin/compare_impls.ml` (code for an executable that tests two modules for observational equivalence)

To run the generated executable, run `dune exec -- bin/compare_impls.exe`. 

### Example (finite sets)
`dune exec -- bin/main.exe lib/sets/SetInterface.ml lib/sets/ListSet.ml lib/sets/BSTSet.ml`         
This runs Mica on the Set example above, checking if the `ListSet` and `BSTSet` modules 
both correctly implement the interface `SetInterface`.       
The files `lib/GeneratedSetPBTCode.ml` and `lib/GeneratedSetExecutable.ml` contain PBT code that is 
automatically generated by Mica. 

### Dependencies:
- [Base](https://github.com/janestreet/base)
- [Core](https://github.com/janestreet/core)
- [Angstrom](https://github.com/inhabitedtype/angstrom)
- [PPrint](https://github.com/fpottier/pprint)
- [Stdio](https://github.com/janestreet/stdio)

## Acknowledgements
- Many thanks to Harry Goldstein & Prof. Benjamin Pierce for their mentorship and advisement.             
- Thanks to Jan Midtggard (Tarides) & Carl Eastlund (Jane Street) for answering 
my questions about QCSTM and Core.Quickcheck. 
- Thanks to Cassia Torczon for the idea behind the name Mica. 


## Origin of name
Mica stands for "Module-Implementation Comparison Automation". Mica's name, a type of 
[mineral](https://en.wikipedia.org/wiki/Mica) commonly found in rocks, was inspired 
by several relevant OCaml libraries that are also named after stones/rocks:         
- [Monolith](https://gitlab.inria.fr/fpottier/monolith) (Randomised testing tool for OCaml modules)
- [Opal](https://github.com/pyrocat101/opal) (parser combinator library)
- [Menhir](http://gallium.inria.fr/~fpottier/menhir/) (parser library)
- [Obelisk](https://github.com/Lelio-Brun/Obelisk) (pretty-printer for Menhir)


## References
- Jane Street's [Base_quickcheck](https://opensource.janestreet.com/base_quickcheck/) & [Core.Quickcheck](https://blog.janestreet.com/quickcheck-for-core/)
- [QCSTM](https://github.com/jmid/qcstm)   
- [Model_quickcheck](https://github.com/suttonshire/model_quickcheck)
- [Monolith](https://gitlab.inria.fr/fpottier/monolith)
- [Articheck](http://www.lix.polytechnique.fr/Labo/Gabriel.Scherer/doc/articheck-long.pdf)
- *Advanced Topics in Types & Programming Languages*, Chapter 8
- *Real World OCaml*  
- [Cornell CS 3110 OCaml textbook](https://cs3110.github.io/textbook/chapters/ds/hash_tables.html#maps-as-hash-tables)
- [Penn CIS 1200 lecture notes](https://www.seas.upenn.edu/~cis120/23su/files/120notes.pdf#page=3)
- [Yale-NUS YSC2229 website](https://ilyasergey.net/YSC2229/week-11-bst.html)
- [Jean-Christophe Filliatre's polynomial implementation](https://www.lri.fr/~filliatr/ftp/ocaml/ds/poly.ml.html)
- [Shayne Fletcher's polynomial implementation](https://blog.shaynefletcher.org/2017/03/polynomials-over-rings.html)

