<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ModuleParser (mica.Lib.ModuleParser)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">mica</a> &#x00BB; <a href="../index.html">Lib</a> &#x00BB; ModuleParser</nav><header class="odoc-preamble"><h1>Module <code><span>Lib.ModuleParser</span></code></h1></header><div class="odoc-content"><p>A parser for module signatures, based on the <a href="https://github.com/inhabitedtype/angstrom">Angstrom</a> parser-combinator library.</p><p>This file depends on helper functions defined in the module <code>Lib.Parser</code>, and datatype definitions defined in <code>Lib.ParserTypes</code>.</p><div class="odoc-spec"><div class="spec module" id="module-A" class="anchored"><a href="#module-A" class="anchor"></a><code><span><span class="keyword">module</span> A</span><span> = <span class="xref-unresolved">Angstrom</span></span></code></div><div class="spec-doc"><p>Alias for the <code>Angstrom</code> module</p></div></div><div class="odoc-spec"><div class="spec value" id="val-identP" class="anchored"><a href="#val-identP" class="anchor"></a><code><span><span class="keyword">val</span> identP : <span>?firstCharP:<span><span class="xref-unresolved">Base</span>.char <span class="xref-unresolved">A</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parsers for identifiers in OCaml <code>ident ::= (A..Z | a..z | _) {A..Z | a..z | 0..9 | _ | \'}</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-lowercaseIdentP" class="anchored"><a href="#val-lowercaseIdentP" class="anchor"></a><code><span><span class="keyword">val</span> lowercaseIdentP : <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for identifiers which start with lowercase letters / an underscore</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeParamP" class="anchored"><a href="#val-typeParamP" class="anchor"></a><code><span><span class="keyword">val</span> typeParamP : <span><span class="xref-unresolved">Base</span>.char <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parses type-parameters, eg. <code>'a</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexpAnnotP" class="anchored"><a href="#val-sexpAnnotP" class="anchor"></a><code><span><span class="keyword">val</span> sexpAnnotP : <span><span class="xref-unresolved">Base</span>.unit <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parses the S-expression PPX annotation, consuming subsequent whitespace TODO: this parser could be written more cleanly</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sigP" class="anchored"><a href="#val-sigP" class="anchor"></a><code><span><span class="keyword">val</span> sigP : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">A</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p><code>sigP p</code> takes a parser <code>p</code>, and sandwiches it between parsers that parse the &quot;sig&quot; and &quot;end&quot; tokens</p></div></div><div class="odoc-spec"><div class="spec value" id="val-modNameP" class="anchored"><a href="#val-modNameP" class="anchor"></a><code><span><span class="keyword">val</span> modNameP : <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for module names, which must start with a capital letter</p></div></div><div class="odoc-spec"><div class="spec value" id="val-baseTypeP" class="anchored"><a href="#val-baseTypeP" class="anchor"></a><code><span><span class="keyword">val</span> baseTypeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for base types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-libraryNameP" class="anchored"><a href="#val-libraryNameP" class="anchor"></a><code><span><span class="keyword">val</span> libraryNameP : <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parses the names of common Jane Street libraries</p></div></div><div class="odoc-spec"><div class="spec value" id="val-paramTypeP" class="anchored"><a href="#val-paramTypeP" class="anchor"></a><code><span><span class="keyword">val</span> paramTypeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>General parser for parameterized types, eg. options/pairs/lists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-opaqueTypeP" class="anchored"><a href="#val-opaqueTypeP" class="anchor"></a><code><span><span class="keyword">val</span> opaqueTypeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for &quot;opaque types&quot;, i.e. types that are sealed within another module, eg. the type <code>M.t</code> from another module <code>M</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-namedAbstractTypeP" class="anchored"><a href="#val-namedAbstractTypeP" class="anchor"></a><code><span><span class="keyword">val</span> namedAbstractTypeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for the <code>NamedAbstract</code> case of the <code>ty</code> datatype, i.e. parser for named monomorphic abstract types, e.g. <code>type private_key</code> in the Diffie-Hellman example</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeP" class="anchored"><a href="#val-typeP" class="anchor"></a><code><span><span class="keyword">val</span> typeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>General parser for non-arrow types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeTokenP" class="anchored"><a href="#val-typeTokenP" class="anchor"></a><code><span><span class="keyword">val</span> typeTokenP : <span><span class="xref-unresolved">Base</span>.unit <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parses the token <code>&quot;type&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-abstractTypeP" class="anchored"><a href="#val-abstractTypeP" class="anchor"></a><code><span><span class="keyword">val</span> abstractTypeP : <span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for the declaration of an abstract type in a module, eg. <code>type 'a t</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-arrowTypeP" class="anchored"><a href="#val-arrowTypeP" class="anchor"></a><code><span><span class="keyword">val</span> arrowTypeP : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for arrow types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valDeclP" class="anchored"><a href="#val-valDeclP" class="anchor"></a><code><span><span class="keyword">val</span> valDeclP : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for a value declaration inside a module, eg. <code>val empty : 'a t</code> or <code>val func : 'a -&gt; 'a t -&gt; 'a t</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-moduleTypeP" class="anchored"><a href="#val-moduleTypeP" class="anchor"></a><code><span><span class="keyword">val</span> moduleTypeP : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="xref-unresolved">A</span>.t</span></span></code></div><div class="spec-doc"><p>Parser for a module signature</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string_of_file" class="anchored"><a href="#val-string_of_file" class="anchor"></a><code><span><span class="keyword">val</span> string_of_file : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Reads a file as a single string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-file_of_string" class="anchored"><a href="#val-file_of_string" class="anchor"></a><code><span><span class="keyword">val</span> file_of_string : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Writes a string to a file</p></div></div></div></body></html>