<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CodeGenerator (mica.Lib.CodeGenerator)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">mica</a> &#x00BB; <a href="../index.html">Lib</a> &#x00BB; CodeGenerator</nav><header class="odoc-preamble"><h1>Module <code><span>Lib.CodeGenerator</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#functions-for-generating-pbt-code">Functions for generating PBT code</a></li><li><a href="#functions-for-generating-the-executable-for-comparing-two-modules">Functions for generating the executable for comparing two modules</a></li></ul></nav><div class="odoc-content"><p>This file contains the logic for generating PBT code from the AST of a parsed module signature. This file also calls some helper functions defined in the module <code>Lib.Utils</code>.</p><h2 id="functions-for-generating-pbt-code"><a href="#functions-for-generating-pbt-code" class="anchor"></a>Functions for generating PBT code</h2><div class="odoc-spec"><div class="spec value" id="val-imports" class="anchored"><a href="#val-imports" class="anchor"></a><code><span><span class="keyword">val</span> imports : 
  <span>externalLib:<span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.option</span> <span class="arrow">&#45;&gt;</span></span>
  <span>sigName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>modName1:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>modName2:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>imports filepath</code> prints out a PPrint document that imports the requisite modules for the PBT code. The <code>sigName, modName1, modName2</code> arguments are the names of the module signatures &amp; the two module implementations, which must be the same as their corresponding <code>.ml</code> files.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexpAnnotation" class="anchored"><a href="#val-sexpAnnotation" class="anchor"></a><code><span><span class="keyword">val</span> sexpAnnotation : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Document for printing the PPX annotation for S-Expr serialization (indented), followed by a newline</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ppxQuickCheckMacro" class="anchored"><a href="#val-ppxQuickCheckMacro" class="anchor"></a><code><span><span class="keyword">val</span> ppxQuickCheckMacro : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Document for invoking the ppx_quickcheck macro for a particular type <code>ty</code> (represented as a string)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArrowType" class="anchored"><a href="#val-isArrowType" class="anchor"></a><code><span><span class="keyword">val</span> isArrowType : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isArrowType v</code> returns true if the value declaration <code>v</code> has an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyIsArrow" class="anchored"><a href="#val-tyIsArrow" class="anchor"></a><code><span><span class="keyword">val</span> tyIsArrow : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>tyIsArrow ty</code> returns true if <code>ty</code> correspons to an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isOpaqueTy" class="anchored"><a href="#val-isOpaqueTy" class="anchor"></a><code><span><span class="keyword">val</span> isOpaqueTy : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isOpaqueTy ty</code> returns <code>true</code> if <code>ty</code> is a string corresponding to an &quot;opaque&quot; type, i.e. a type originating from another module</p><ul><li>Eg. if <code>ty = &quot;AssocListT&quot;</code>, then ty is actually <code>&quot;AssocList.t&quot;</code> where <code>AssocList</code> is some externally-defined module</li><li>Note: the only critiera for evaluating if a type is an opaque type is just checking if the type name ends with the substring &quot;.t&quot; (this heuristic may be replaced with a more robust mechanism in the future)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-getIdentityElements" class="anchored"><a href="#val-getIdentityElements" class="anchor"></a><code><span><span class="keyword">val</span> getIdentityElements : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Extracts all the &quot;identity elements&quot; defined within a module signature, e.g. <code>mempty</code> for monoids, or <code>zero</code> &amp; <code>one</code> for semirings</p><ul><li>For our purposes, we assume any declaration of the form <code>val x : t</code> in the module signature, where <code>t</code> is the module's abstract type, is an identity element</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-extractArgTypes" class="anchored"><a href="#val-extractArgTypes" class="anchor"></a><code><span><span class="keyword">val</span> extractArgTypes : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Extracts the argument types of functions defined in the module signature, and generates constructors for the <code>expr</code> ADT that take these types as type parameters</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exprADTDecl" class="anchored"><a href="#val-exprADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> exprADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>expr</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printConstructor" class="anchored"><a href="#val-printConstructor" class="anchor"></a><code><span><span class="keyword">val</span> printConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Helper function for printing out OCaml constructors (Wrapper for the <code>OCaml.variant</code> function in the <code>PPrint</code> library)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-reifyOpaqueTyConstr" class="anchored"><a href="#val-reifyOpaqueTyConstr" class="anchor"></a><code><span><span class="keyword">val</span> reifyOpaqueTyConstr : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-splitCamelCaseTyString" class="anchored"><a href="#val-splitCamelCaseTyString" class="anchor"></a><code><span><span class="keyword">val</span> splitCamelCaseTyString : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ty_of_string" class="anchored"><a href="#val-ty_of_string" class="anchor"></a><code><span><span class="keyword">val</span> ty_of_string : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a></span></code></div><div class="spec-doc"><p><code>ty_of_string s</code> converts a string <code>s</code> denoting a type to the equivalent <code>ty</code> ADT constructor of its <i>base type</i> by running the parser <code>typeP</code> (defined in <code>Lib.ModuleParser</code>) over <code>s</code>.</p><ul><li>Note: The string <code>s</code> must be in camel-case</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-namedAbsTyVarNameHelper" class="anchored"><a href="#val-namedAbsTyVarNameHelper" class="anchor"></a><code><span><span class="keyword">val</span> namedAbsTyVarNameHelper : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Takes <code>tyName</code>, the name of a named abstract type (eg. <code>public_key</code>), and produces a varname as follows:</p><ul><li>Split on underscores</li><li>fetch the 1st letter of each substring</li><li>Concat all the 1st letters of the substrings</li><li>eg. if the type name is <code>public_key</code>, then the varname is <code>pk</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-varNameHelper" class="anchored"><a href="#val-varNameHelper" class="anchor"></a><code><span><span class="keyword">val</span> varNameHelper : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p><code>varNameHelper ty</code> returns an appropriate variable name corresponding to <code>ty</code>, eg. <code>varNameHelper Int = n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNameSingleton" class="anchored"><a href="#val-genVarNameSingleton" class="anchor"></a><code><span><span class="keyword">val</span> genVarNameSingleton : <span>?prime:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Special case of <code>genVarNames</code> when we only have one argument type. If <code>prime = true</code>, add a single quote to the end of the variable name</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNamesN" class="anchored"><a href="#val-genVarNamesN" class="anchor"></a><code><span><span class="keyword">val</span> genVarNamesN : <span>n:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates <code>n</code> unique variable names corresponding to a type <code>ty</code>. For example, <code>genVarNamesN 3 Int</code> produces <code>[&quot;n1&quot;; &quot;n2&quot;; &quot;n3&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNames" class="anchored"><a href="#val-genVarNames" class="anchor"></a><code><span><span class="keyword">val</span> genVarNames : 
  <span>?prime:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Takes a list of argument types, and generates corresponding variable names which are unique for each element of the list eg. <code>genVarNames [Int; Int; Char] = [n1; n2; c]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorName" class="anchored"><a href="#val-getExprConstructorName" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Fetches the <code>expr</code> constructor corresponding to a <code>val</code> declaration in a module</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructor" class="anchored"><a href="#val-getExprConstructor" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructor : 
  <span>idElts:<span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Fetches the constructor corresponding to a <code>val</code> declaration in the <code>expr</code> ADT, returning a pair of the form <code>(args, constructor applied to args)</code>, eg. <code>([&quot;x&quot;, &quot;e&quot;], !^ &quot;Mem(x,e)&quot;)</code></p><ul><li>The auxiliary argument <code>idElts</code> is a list of names of the identity elements defined in the module signature (eg. <code>mempty</code> for monoids)</li><li>See <code>getIdentityElements</code> for further details on identity elements</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-extractReturnType" class="anchored"><a href="#val-extractReturnType" class="anchor"></a><code><span><span class="keyword">val</span> extractReturnType : <span>?camelCase:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p><code>extractReturnType camelCase v</code> extracts the string representation of the return type of a function, if <code>v</code> is a <code>valDecl</code> corresponding to an arrow type.</p><ul><li>For non-arrow types, this function just extracts the type itself.</li><li>The optional argument <code>camelCase</code> determines whether the string returned should be in camelCase or not.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uniqRetTypesInSig" class="anchored"><a href="#val-uniqRetTypesInSig" class="anchor"></a><code><span><span class="keyword">val</span> uniqRetTypesInSig : 
  <span>?camelCase:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Fetches the unique return types across the functions / values in a module signature.</p><ul><li>The optional argument <code>camelCase</code> determines whether the string returned should be in camelCase or not.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTDecl" class="anchored"><a href="#val-tyADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> tyADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ty</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getFuncName" class="anchored"><a href="#val-getFuncName" class="anchor"></a><code><span><span class="keyword">val</span> getFuncName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Given a <code>val</code> declaration inside a module (eg. <code>val f : 'a -&gt; 'a</code>), returns the corresponding function name (eg. <code>M.f</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructorString" class="anchored"><a href="#val-valADTConstructorString" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructorString : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Like <code>valADTConstructor</code> (see below), but returns a string instead of a PPrint document</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructor" class="anchored"><a href="#val-valADTConstructor" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTConstructor ty</code> generates the constructor name for the <code>value</code> ADT corresponding to the type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTConstructors" class="anchored"><a href="#val-tyADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyADTConstructors : 
  <span>?camelCase:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates the list of constructor names (strings) for the <code>ty</code> ADT</p><ul><li>The optional argument <code>camelCase</code> determines whether the strings returned should be in camelCase or not.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-tyAndValADTConstructors" class="anchored"><a href="#val-tyAndValADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyAndValADTConstructors : 
  <span>?camelCase:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Returns an association list of string pairs, where each element is a constructor for the <code>ty</code> ADT &amp; its associated constructor for the <code>value</code> ADT.</p><ul><li>The optional argument <code>camelCase</code> determines whether the strings returned should be in camelCase or not.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiateT" class="anchored"><a href="#val-instantiateT" class="anchor"></a><code><span><span class="keyword">val</span> instantiateT : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div><div class="spec-doc"><p>Takes <code>s</code>, a string reprentation of a type, and instantiates the abstract type <code>t</code> to <code>int M.t</code> where <code>M</code> is some module defined elsewhere.</p><ul><li>Example: <code>instantiate &quot;toption&quot; = &quot;int M.t option&quot;</code></li><li>If <code>s</code> doesn't contain the prefix <code>&quot;t&quot;</code>, <code>s</code> is left unchanged</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-addSpaceToTyStr" class="anchored"><a href="#val-addSpaceToTyStr" class="anchor"></a><code><span><span class="keyword">val</span> addSpaceToTyStr : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div><div class="spec-doc"><p>Takes <code>s</code>, a string reprentation of a type, and adds a space to <code>s</code> if <code>s</code> represents a parameterized type.</p><ul><li>Example: <code>addSpaceToTyStr &quot;intoption&quot; = &quot;int option&quot;</code></li><li>If <code>s</code> doesn't contain the suffix <code>&quot;list&quot;</code> or <code>&quot;option&quot;</code>, <code>s</code> is left unchanged.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-destructAbsTy" class="anchored"><a href="#val-destructAbsTy" class="anchor"></a><code><span><span class="keyword">val</span> destructAbsTy : <span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>destructAbsTy</code> takes an abstract type <code>absTy</code> and produces a PPrint document referencing <code>absTy</code> inside some module <code>M</code>. For example, the abstract type <code>t</code> (represented as the inhabitant <code>T0 &quot;t&quot;</code> of the type <code>abstractType</code>) corresponds to <code>&quot;M.t&quot;</code>.</p><ul><li>Note: any polymorphic type variables are automatically instantiated with <code>int</code>, so <code>'a t</code> becomes <code>&quot;int M.t&quot;</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-lookupAbsTy" class="anchored"><a href="#val-lookupAbsTy" class="anchor"></a><code><span><span class="keyword">val</span> lookupAbsTy : 
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> option</span></span></code></div><div class="spec-doc"><p>Takes a list <code>absTys</code> of abstract types and checks if the string <code>s</code> is the name of an abstract type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTParam" class="anchored"><a href="#val-valADTParam" class="anchor"></a><code><span><span class="keyword">val</span> valADTParam : 
  <span>moduleAbsTys:<span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?isOpaque:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTParam moduleAbsTy ty</code> takes <code>ty</code>, a string representation of the corresponding type, and generates the type parameter for the constructor <code>value</code> ADT corresponding to the type <code>ty</code>.</p><ul><li>The auxiliary argument <code>moduleAbsTy</code> refers to the abstract type contained within the module signature, e.g. <code>M.t</code></li><li>The optional argument <code>isOpaque</code> is a boolean indicating whether this type is &quot;opaque&quot; (i.e. originating from another module, eg. <code>&quot;AssocList.t&quot;</code> where &quot;AssocList&quot; is an externally-defined module)</li><li>If the module's abstract type <code>M.t</code> is polymorphic (i.e. <code>'a M.t</code>), we instantiate <code>'a</code> with <code>int</code>, otherwise we leave the abstract type monomorphic (i.e. just <code>M.t</code>)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTTypeDef" class="anchored"><a href="#val-valADTTypeDef" class="anchor"></a><code><span><span class="keyword">val</span> valADTTypeDef : 
  <span>moduleAbsTys:<span><a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTTypeDef moduleAbsTy ty</code> generates both the constructor &amp; type parameter for the <code>value</code> ADT corresponding to the type <code>ty</code></p><ul><li>The auxiliary argument <code>moduleAbsTy</code> is the abstract type defined in the module, which is used to determine if the abstract type needs to be instantiated with a concrete type (this logic is handled in <code>valADTParam</code>)</li><li>Note: This function is a helper function called by <code>valADTDefn</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTDefn" class="anchored"><a href="#val-valADTDefn" class="anchor"></a><code><span><span class="keyword">val</span> valADTDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the <code>value</code> ADT definition that is contained within the module returned by the <code>ExprToImpl</code> functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpIsNeeded" class="anchored"><a href="#val-interpIsNeeded" class="anchor"></a><code><span><span class="keyword">val</span> interpIsNeeded : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p>Given an argument and its type, determines if we need to recursively call <code>interp</code> on the argument for the inner pattern match in <code>interp</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-argPos" class="anchored"><a href="#type-argPos" class="anchor"></a><code><span><span class="keyword">type</span> argPos</span><span> = </span></code><table><tr id="type-argPos.Fst" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Fst" class="anchor"></a><code><span>| </span><span><span class="constructor">Fst</span></span></code></td></tr><tr id="type-argPos.Snd" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Snd" class="anchor"></a><code><span>| </span><span><span class="constructor">Snd</span></span></code></td></tr></table></div><div class="spec-doc"><p>Auxiliary data type for indicating the position of a non-<code>expr</code> argument to a function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-argPos_of_sexp" class="anchored"><a href="#val-argPos_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> argPos_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-argPos">argPos</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_argPos" class="anchored"><a href="#val-sexp_of_argPos" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_argPos : <span><a href="#type-argPos">argPos</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-interpOnce" class="anchored"><a href="#val-interpOnce" class="anchor"></a><code><span><span class="keyword">val</span> interpOnce : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?nonExprArg:<span><span>(string * <a href="#type-argPos">argPos</a>)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on one argument of type <code>expr</code>. If <code>nonExprArg</code> is <code>Some</code> of some value, it is placed in the appropriate argument position during function application.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpTwice" class="anchored"><a href="#val-interpTwice" class="anchor"></a><code><span><span class="keyword">val</span> interpTwice : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on two arguments, both of type <code>expr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpExprPatternMatch" class="anchored"><a href="#val-interpExprPatternMatch" class="anchor"></a><code><span><span class="keyword">val</span> interpExprPatternMatch : 
  <span><span>(<a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the inner pattern match (<code>interp e</code>) in the <code>interp</code> function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpDefn" class="anchored"><a href="#val-interpDefn" class="anchor"></a><code><span><span class="keyword">val</span> interpDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>interpDefn m</code> generates the definition of the <code>interp</code> function, which evaluates <code>expr</code>s based on the value declarations defined in the module signature <code>m</code>. This function does so by doing the following:</p><ul><li>Extracting the names of all the identity elements in <code>m</code> by calling <code>getIdentityElements</code></li><li>Fetching the <code>expr</code> ADT constructors &amp; arguments based on the declarations inside <code>m</code></li><li>Generating the pattern matches inside the <code>interp</code> function</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-functorDef" class="anchored"><a href="#val-functorDef" class="anchor"></a><code><span><span class="keyword">val</span> functorDef : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span>sigName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>functorName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ExprToImpl</code> functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getGenerator" class="anchored"><a href="#val-getGenerator" class="anchor"></a><code><span><span class="keyword">val</span> getGenerator : <span>?nonNegOnly:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>getGenerator ty</code> takes in a type <code>ty</code> and produces a PPrint document containing the corresponding QuickCheck generator for that type.</p><ul><li>The auxiliary argument <code>nonNegOnly</code> specifies whether QuickCheck's int generators should only generate non-negative ints (in the event <code>ty</code> is <code>Int</code>).</li><li>By default, the int generator returned generates both negative &amp; positive ints.</li><li>Note that polymorphic types (eg. <code>Alpha</code>) are instantiated as ints</li><li>This is a helper function called by <code>argGen</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-argGen" class="anchored"><a href="#val-argGen" class="anchor"></a><code><span><span class="keyword">val</span> argGen : 
  <span>?nonNegOnly:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?pairName:<span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.Option.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the code for a monadic bind of <code>arg</code> to a QuickCheck generator producing a value of type <code>ty</code>, where <code>ty</code> must be a non-arrow type.</p><ul><li>This is a helper function called by <code>genExprPatternRHS</code>.</li><li>The optional argument <code>nonNegOnly</code> specifies whether QuickCheck's int generators should only generate non-negative ints</li><li>If the optional argument <code>pairName</code> (of type <code>string option</code>) is <code>Some p</code> and <code>ty</code> is of the form <code>Pair (_, _)</code>, <code>p</code> will be used as the variable name for the overall pair.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-isPairType" class="anchored"><a href="#val-isPairType" class="anchor"></a><code><span><span class="keyword">val</span> isPairType : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isPairType ty</code> returns <code>true</code> if <code>ty</code> is a pair type, <code>false</code> otherwise</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatternRHS" class="anchored"><a href="#val-genExprPatternRHS" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatternRHS : 
  <span>?nonNegOnly:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string
   * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
   * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
   * <span class="xref-unresolved">Base</span>.string
   * <span class="xref-unresolved">PPrint</span>.document)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span></span></code></div><div class="spec-doc"><p>Takes in the following arguments:</p><ul><li><code>nonNegOnly</code>: An optional argument specifying whether QuickCheck's int generators should only generate non-negative ints</li><li><code>tyConstr</code>: constructor for the <code>ty</code> ADT representing the return type of a function</li><li><code>funcTy</code>: function type</li><li><code>args</code>: arguments passed to the <code>Expr</code> constructor</li><li><code>constr</code>: constructor for the <code>Expr</code> ADT</li><li><code>funcApp</code>: PPrint document containing the application of <code>constr</code> onto <code>args</code></li></ul><p>This function produces the RHS of the pattern matches in <code>gen_expr</code>, returning a tuple of the form <code>(tyConstr, (ty, patternMatchRHS, nameOfPatternMatch))</code></p><p>For example, if:</p><ul><li><code>tyConstr = Bool</code></li><li><code>ty = Func2(Alpha, Expr, Bool)</code></li><li><code>constr = Mem</code></li><li><p><code>funcApp = Mem(x, e)</code> then <code>genExprPatternRHS (tyConstr, ty, args, constr, funcApp)</code> produces the code</p><pre><code>let%bind arg = G.int in G.return @@ Mem(x, e)</code></pre><p>where <code>G</code> = <code>Base_quickcheck.Generator</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorWithArgs" class="anchored"><a href="#val-getExprConstructorWithArgs" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorWithArgs : 
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string
  * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
  * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
  * <span class="xref-unresolved">Base</span>.string
  * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><b>Arguments</b>:</p><ul><li><code>tyConstr</code> (constructor for the <code>ty</code> ADT representing the return type of a function)</li><li><code>ty</code> (the type of the <code>Expr</code> construcctor)</li><li><code>constr</code> (the string representation of an <code>Expr</code> constructor)</li></ul><p><b>Returns</b>: a 5-tuple of the form</p><pre><code>(tyConstr, ty, constructorArgs, constructor, constructor applied to args) </code></pre><p>e.g.</p><pre><code>(Bool, Func2(Alpha, Expr, Bool), [&quot;x&quot;, &quot;e&quot;], &quot;Mem&quot;, !^ &quot;Mem(x,e)&quot;) </code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatterns" class="anchored"><a href="#val-genExprPatterns" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatterns : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span>)</span> <span class="xref-unresolved">Base</span>.List.t</span></span></code></div><div class="spec-doc"><p>Returns an association list of constructors for the <code>ty</code> ADT where each element is the form <code>(&lt;constructor for the ty ADT&gt;, ty)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-setNonNegIntFlag" class="anchored"><a href="#val-setNonNegIntFlag" class="anchor"></a><code><span><span class="keyword">val</span> setNonNegIntFlag : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a></span></code></div><div class="spec-doc"><p><code>setNonNegIntFlag m</code> sets the <code>intFlag</code> field of the module signature <code>m</code> to <code>NonNegativeOnly</code>, indicating that QuickCheck's int generators should only generate non-negative ints.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprDef" class="anchored"><a href="#val-genExprDef" class="anchor"></a><code><span><span class="keyword">val</span> genExprDef : 
  <span>nonNegOnly:<span class="xref-unresolved">Base</span>.bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the definition of the <code>gen_expr</code> Quickcheck generator for the <code>expr</code> datatype.</p><ul><li>The auxiliary argument <code>nonNegOnly</code> is a boolean specifying if QuickCheck's integer generators should only generate non-negative integers. (This is an optional command-line flag that is passed in when Mica is invoked.)</li><li>An example of the automatically-produced code for <code>gen_expr</code> can be found in <code>GeneratedSetPBTCode.ml</code> (specialized to the finite set example discussed in the README / documentation homepage).</li><li>When the internal size parameter of <code>gen_expr</code> reaches 0, the function yields a trivial generator that just returns the identity element (or one of them, if there are multiple) of the signature.</li><li>See <code>getIdentityElements</code> for a further discussion on identity elements.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-functorApp" class="anchored"><a href="#val-functorApp" class="anchor"></a><code><span><span class="keyword">val</span> functorApp : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces a PPrint document representing an OCaml functor application, where <code>functorName</code> is the name of the functor, and <code>arg</code> is the name of the argument to the functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-implModuleBindings" class="anchored"><a href="#val-implModuleBindings" class="anchor"></a><code><span><span class="keyword">val</span> implModuleBindings : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the module bindings for the two module implemntations <code>I1, I2</code>, where <code>functorName</code> is the name of the functor that procduces the PBT test harness, and <code>modName1</code> &amp; <code>modName2</code> are the names of the two module implementaitons</p></div></div><h2 id="functions-for-generating-the-executable-for-comparing-two-modules"><a href="#functions-for-generating-the-executable-for-comparing-two-modules" class="anchor"></a>Functions for generating the executable for comparing two modules</h2><div class="odoc-spec"><div class="spec value" id="val-displayErrorDef" class="anchored"><a href="#val-displayErrorDef" class="anchor"></a><code><span><span class="keyword">val</span> displayErrorDef : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of a <code>displayError</code> helper function for displaying error messages when QuickCheck tests fail</p></div></div><div class="odoc-spec"><div class="spec value" id="val-executableImports" class="anchored"><a href="#val-executableImports" class="anchor"></a><code><span><span class="keyword">val</span> executableImports : 
  <span>pbtFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>execFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate requisite imports for the executable file, where <code>filepath</code> is the filepath to the executable file</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getTestName" class="anchored"><a href="#val-getTestName" class="anchor"></a><code><span><span class="keyword">val</span> getTestName : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Given <code>tyConstr</code>, a constructor in the <code>ty</code> datatype to an OCaml datatype, <code>getTestName tyConstr</code> produces an interstitial variable name corresponding to this type with the prefix <code>&quot;test_&quot;</code>, in the form of a PPrint document</p><ul><li>For example, <code>getTestName Int</code> produces <code>&quot;test_int&quot;</code> (as a PPrint document)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-obsEquiv" class="anchored"><a href="#val-obsEquiv" class="anchor"></a><code><span><span class="keyword">val</span> obsEquiv : <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces Quickcheck code in the executable that tests two modules for observational equivalence based on <code>expr</code>s that return some <code>tyConstr</code> of type <code>ty</code>, and pattern matching on the equivalent <code>valConstr</code>s that they return</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isExcludedType" class="anchored"><a href="#val-isExcludedType" class="anchor"></a><code><span><span class="keyword">val</span> isExcludedType : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isExcludedType ty</code> returns true if the type <code>ty</code> is a return type to be excluded from consideration when testing for <i>observational equivalence</i>.</p><ul><li>For example, expressions returning abstract types <code>T</code> and <code>AlphaT</code> are excluded when we check if two modules for observational equivalence, because these abstract types may be instantiated differently in the two modules.</li><li>For instance, one module could instantiate <code>'a t</code> to be <code>'a list</code>, while the other instantiates <code>'a t</code> to be <code>'a tree</code>.</li><li>Note: we cannot test opaque types and named abstract types directly for observational equivalence (due to encapsulation, we can't inspect these types directly)</li><li>Note that arrow types are not considered by this function.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compareImpls" class="anchored"><a href="#val-compareImpls" class="anchor"></a><code><span><span class="keyword">val</span> compareImpls : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate the executable code for testing observational equivalence of two modules</p></div></div></div></body></html>