<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stats (mica.Lib.Stats)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">mica</a> &#x00BB; <a href="../index.html">Lib</a> &#x00BB; Stats</nav><header class="odoc-preamble"><h1>Module <code><span>Lib.Stats</span></code></h1></header><div class="odoc-content"><p>Utility functions for printing out distributions of reified values over the modules under test.</p><ul><li>Note: This module is intended to be <code>open</code>ed before the file containing the auto-generated PBT code is <code>open</code>ed. Note that the type <code>expr</code> is declared abstractly in the file, whereas <code>expr</code> is instantiated with a concrete definition in the auto-generated files produced by Mica (e.g. <code>lib/generated.ml</code>). <code>Open</code>ing this file prior to <code>open</code>ing <code>lib/generated.ml</code> will allow these utility functions to operate on the concrete definition of the <code>expr</code> datatype.</li><li>See <code>bin/GeneratedSetExecutable.ml</code> for an example of how to invoke the functions in this file</li></ul><div class="odoc-spec"><div class="spec type" id="type-expr" class="anchored"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span></code></div><div class="spec-doc"><p>Abstract type of <i>symbolic expressions</i></p></div></div><div class="odoc-spec"><div class="spec value" id="val-expr_of_sexp" class="anchored"><a href="#val-expr_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> expr_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_expr" class="anchored"><a href="#val-sexp_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_expr" class="anchored"><a href="#val-compare_expr" class="anchor"></a><code><span><span class="keyword">val</span> compare_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Expr" class="anchored"><a href="#module-Expr" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Expr/index.html">Expr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module containing a comparator witness &amp; serialization functions for the <code>expr</code> datatype. This module is necessary for creating maps/sets over <code>expr</code>s -- see <a href="https://dev.realworldocaml.org/maps-and-hashtables.html">Chapter 14</a> of <i>Real World OCaml</i> for further details on this programming idiom. (Also need to update the appropriate PPX macro invocations in <code>GeneratedSetPBTCode.ml</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq_coverage" class="anchored"><a href="#val-seq_coverage" class="anchor"></a><code><span><span class="keyword">val</span> seq_coverage : <span><span><a href="#type-expr">expr</a> <span class="xref-unresolved">Core</span>.Sequence.t</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Core</span>.Map.M(<span class="xref-unresolved">Expr</span>).t</span></span></code></div><div class="spec-doc"><p>Given a sequence <code>seq</code> of generated <code>expr</code>s, <code>seq_coverage seq</code> produces a <code>Map</code> which maps each unique <code>expr</code> to its frequency in <code>seq</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genSeqPrintFreq" class="anchored"><a href="#val-genSeqPrintFreq" class="anchor"></a><code><span><span class="keyword">val</span> genSeqPrintFreq : <span><span><a href="#type-expr">expr</a> <span class="xref-unresolved">Base_quickcheck</span>.Generator.t</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>genSeqPrintFreq gen</code> takes a generator <code>gen</code> of <code>expr</code>s, uses <code>gen</code> to produce a random sequence of <code>expr</code>s, and prints the frequency of each <code>expr</code> in the random sequence to <code>stdout</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-incrFreq" class="anchored"><a href="#val-incrFreq" class="anchor"></a><code><span><span class="keyword">val</span> incrFreq : 
  <span><span><span>( <span class="type-var">'a</span>, int, <span class="type-var">'comparator</span> )</span> <span class="xref-unresolved">Core</span>.Map.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, int, <span class="type-var">'comparator</span> )</span> <span class="xref-unresolved">Core</span>.Map.t</span></span></code></div><div class="spec-doc"><p><code>incrFreq m key</code> increments the frequency of <code>key</code> in the map <code>m</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-incrHashtbl" class="anchored"><a href="#val-incrHashtbl" class="anchor"></a><code><span><span class="keyword">val</span> incrHashtbl : <span><span><span>( <span class="type-var">'a</span>, int )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Increments the value of a key in a Hashtbl mapping <code>'a</code> values to <code>int</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprWithLog" class="anchored"><a href="#val-genExprWithLog" class="anchor"></a><code><span><span class="keyword">val</span> genExprWithLog : 
  <span><span><a href="#type-expr">expr</a> <span class="xref-unresolved">Base_quickcheck</span>.Generator.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="#type-expr">expr</a>, int )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-expr">expr</a> <span class="xref-unresolved">Base_quickcheck</span>.Generator.t</span></span></code></div><div class="spec-doc"><p><code>genExprWithLog gen h</code> takes a generator <code>gen</code> of <code>expr</code>s, and produces a new generator that generates the same values but also increments a hashtable <code>h</code> of frequencies (mapping <code>expr</code> to <code>int</code>) every time a value is generated</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sumValues" class="anchored"><a href="#val-sumValues" class="anchor"></a><code><span><span class="keyword">val</span> sumValues : <span><span><span>( <span class="type-var">'a</span>, int )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Computes the sum of all the values in the hashmap <code>h</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-computePercents" class="anchored"><a href="#val-computePercents" class="anchor"></a><code><span><span class="keyword">val</span> computePercents : 
  <span><span><span>( <span class="type-var">'a</span>, int )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span class="type-var">'a</span>, float )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>Takes a hashtable mapping <code>'a</code> keys to their occurrences, and converts it into a hashtable mapping <code>'a</code> to their frequency (as a percentage)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sortByPercent" class="anchored"><a href="#val-sortByPercent" class="anchor"></a><code><span><span class="keyword">val</span> sortByPercent : <span><span><span>( <span class="type-var">'a</span>, int )</span> <span class="xref-unresolved">Core</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(float * <span class="type-var">'a</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Takes a hashtable mapping <code>'a</code> keys to their integer frequency, computes the frequency of each key as a percentage, then returns a <code>float * 'a list</code> association list sorted in descending order of percentage (highest frequency comes first)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printPercents" class="anchored"><a href="#val-printPercents" class="anchor"></a><code><span><span class="keyword">val</span> printPercents : 
  <span>?precision:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(float * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(float * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>printKey:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints the percentages of two pairs, each of type <code>float * 'a list</code></p><ul><li>The argument <code>~printKey</code> converts type <code>'a</code> to <code>string</code> for printing</li><li>The argument <code>~precision</code> specifies the no. of characters to print in the string representation of the <code>'a</code> type. The default precision is 10.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-printPercent" class="anchored"><a href="#val-printPercent" class="anchor"></a><code><span><span class="keyword">val</span> printPercent : 
  <span>?precision:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(float * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>printKey:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Prints a percentage of a pair of type <code>float * 'a</code>, where the percentage is the first element of the pair</p><ul><li>See <code>printPercents</code> for explanations of the named arguments <code>precision</code> and <code>printKey</code></li></ul></div></div><p>Prints the percentage of each <code>key</code>'s occurrence in the hashtable <code>h</code>, using <code>printKey</code> as the serialization for <code>key</code>s of type <code>'a</code></p></div></body></html>