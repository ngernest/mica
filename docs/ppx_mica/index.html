<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ppx_mica.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ ppx_mica</nav><header class="odoc-preamble"><h1 id="mica:-automated-differential-testing-for-ocaml-modules"><a href="#mica:-automated-differential-testing-for-ocaml-modules" class="anchor"></a>Mica: Automated Differential Testing for OCaml Modules</h1><p><b>Note</b>: Mica is a research prototype and should not be used in production code. (We have made Mica available on Opam so that others may try it out &amp; contribute to Mica if they wish.) Please contact Ernest Ng (<code>ernest@cs.cornell.edu</code>) if you'd like to contribute to Mica or have any questions!</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#using-mica">Using Mica</a><ul><li><a href="#limitations">Limitations</a></li></ul></li><li><a href="#compilation-notes">Compilation notes</a></li><li><a href="#case-studies">Case Studies</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>Mica is a PPX extension that automates differential testing for a pair of OCaml modules implementing the same signature. Users annotate module signatures with the directive <code>[@@deriving mica]</code>, and at compile-time, Mica derives specialized <a href="https://www.youtube.com/watch?v=qmA9qhaECcE">property-based testing</a> (PBT) code that checks if two modules implementing the signature are observationally equivalent. (Under the hood, Mica uses Jane Street's <a href="https://blog.janestreet.com/quickcheck-for-core/"><code>Core.Quickcheck</code></a> PBT library.)</p><p>Mica was presented at the OCaml Workshop '24 and the ICFP '23 SRC. The <a href="https://www.arxiv.org/abs/2408.14561">OCaml Workshop paper</a> contains a lot more details about Mica's design -- this README focuses on describing how to interact with our OCaml artifact.</p><p>An online demo of Mica is available <a href="https://ngernest.github.io/mica/demo.html"><b>here</b></a>.</p><h2 id="using-mica"><a href="#using-mica" class="anchor"></a>Using Mica</h2><p>Here is how we envisage users interacting with Mica:</p><p>Suppose modules <code>M1</code> &amp; <code>M2</code> both implement the module signature <code>S</code>. Users insert the directive <code>[@@deriving_inline mica]</code> beneath the definition of <code>S</code>, like so:</p><pre class="language-ocaml"><code>module type S = sig
  type 'a t 
  val empty : 'a t
  val add : 'a -&gt; 'a t -&gt; 'a t
  ...
end
[@@deriving_inline mica] 
...
[@@@end]</code></pre><p>Then, after users run <code>dune build --auto-promote</code>, the derived PBT code is automatically inserted in-line in the source file in-between <code>[@@deriving_inline mica]</code> and <code>[@@@end]</code>. (Note: this doesn't work fully out of the box at the moment -- see <a href="#compilation-notes">compilation notes</a> for details.)</p><p>Then, after running <code>dune build</code>, Mica derives the following PBT code:</p><pre class="language-ocaml"><code>module Mica = struct 
  (** [expr] is an inductively-defined algebraic data type 
      representing {i symbolic expressions}. 
      
      Each [val] declaration in the module signature [S] corresponds to a 
      cosntructor for [expr] that shares the same name, arity &amp; argument types. 
      - Type variables ['a] are instantiated with [int]
      - Function arguments of type ['a t] correpond to
        constructor arguments of type [expr] *)
  type expr =
    | Empty
    | Is_empty of expr
    ...
  [@@deriving show, ...]

  (** Types of symbolic expressions *)
  type ty = Int | IntT | ... [@@deriving show, ...]

  (** QuickCheck generator for symbolic expressions. 
      [gen_expr ty] generates random [expr]s of type [ty]. *)
  let rec gen_expr : ty -&gt; Core.Quickcheck.Generator.t = ...

  (** Functor that interprets symbolic expressions *)
  module Interpret (M : S) = struct   
    (** Values of symbolic expressions *)
    type value = ValInt of int | ValIntT of int M.t | ...

    (** Big-step interpreter for symbolic expressions: 
        [interp] takes an [expr] and interprets it over the module 
        [M], evaluating the [expr] to a [value] *)
    let rec interp : expr -&gt; value = ...
  end 

  (** Functor that tests [M1] and [M2] for observational equivalence *)
  module TestHarness (M1 : S) (M2 : S) = struct 
    (* Runs all observational equivalence tests *)
    let run_tests : unit -&gt; unit = ... 
  end
end</code></pre><ul><li>Now suppose modules <code>M1</code> and <code>M2</code> both implement <code>S</code>. To run Mica's testing code and check whether <code>M1</code> &amp; <code>M2</code> are observationally equivalent with respect to <code>S</code>, one can invoke the <code>run_tests : unit -&gt; unit</code> function in Mica's <code>TestHarness</code> functor, like so:</li></ul><pre class="language-ocaml"><code>module T = Mica.TestHarness(M1)(M2)
let () = T.run_tests ()</code></pre><ul><li><b>Note</b>: Mica only tests for observational equivalence at <em>concrete types</em> (e.g. <code>int</code>, <code>string option</code>), and not abstract types defined in a module (e.g. <code>'a M.t</code>), since abstract types have a more abstract notion of equality different from OCaml's standard notion of polymorphic equality.</li></ul><h3 id="limitations"><a href="#limitations" class="anchor"></a>Limitations</h3><p>At the moment, Mica only works with module signatures that define one abstract type (e.g. <code>t</code> or <code>'a t</code>) and only contain pure functions. Modules with multiple abstract types and/or abstract types with multiple type parameters are not supported at the moment.</p><h2 id="compilation-notes"><a href="#compilation-notes" class="anchor"></a>Compilation notes</h2><p>There is a known issue with Ppxlib (<a href="https://github.com/ocaml-ppx/ppxlib/issues/338">#338</a>, <a href="https://github.com/ocaml-ppx/ppxlib/issues/342">#342</a>) which causes Ppxlib to error when Dune is promoting changes (i.e. after one runs <code>dune build --auto-promote</code>, during which Dune inserts the code derived by Mica into the source file).</p><p>To fix this issue, remove <code>[@@deriving_inline mica]</code> and <code>[@@@end]</code> from the source file while keeping the code inserted by Dune/Mica. Then, recompile by running <code>dune build again</code>. This second compilation run should complete successfully!</p><h2 id="case-studies"><a href="#case-studies" class="anchor"></a>Case Studies</h2><p>Code for the following case studies (along with the code automatically derived by Mica) is located in the ancillary <a href="https://github.com/ngernest/mica_case_studies"><code>mica_case_studies</code></a> repo.</p><p>We have tested Mica with the following module signatures, each of which is implemented by two different modules:</p><ul><li>Finite Sets (lists &amp; Binary Search Trees) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/sets">link</a>)</li><li>Regular Expression Matchers (Brzozowski Derivatives &amp; Deterministic Finite Automata) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/regexes/">link</a>)</li><li>Polynomials (Horner schema &amp; monomial-based representations) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/polynomials/">link</a>)</li><li>Ephemeral Queues (<a href="https://ocaml.janestreet.com/ocaml-core/v0.13/doc/base/Base/Queue/index.html"><code>Base.Queue</code></a> &amp; <a href="https://ocaml.janestreet.com/ocaml-core/v0.12/doc/base/Base/Linked_queue/index.html"><code>Base.Linked_queue</code></a>) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/queues/">link</a>)</li><li>Unsigned integer arithmetic (the <a href="https://github.com/andrenth/ocaml-stdint/tree/master"><code>stdint</code></a> and <a href="https://github.com/yallop/ocaml-integers"><code>ocaml-integers</code></a> libraries) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/unsigned_ints/">link</a>)</li><li>Character sets (the <a href="https://github.com/yallop/ocaml-charset"><code>charset</code></a> library &amp; the standard library's <code>Set.Make(Char)</code> module) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/charsets/">link</a>)</li><li>Persistent maps (red-black trees &amp; association lists) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/maps/">link</a>)</li><li>John Hughes's <em>How to Specify It</em> (catching bugs in BST implementations) (<a href="https://github.com/ngernest/mica_case_studies/tree/main/lib/how_to_specify_it/">link</a>)</li><li>UPenn CIS 1200 student homework submissions (<a href="./lib/student_submissions/">link</a>)</li></ul><p>For more details regarding these case studies, we refer the reader to the <a href="https://github.com/ngernest/mica_case_studies"><code>mica_case_studies</code></a> repo as well as the <a href="https://www.arxiv.org/abs/2408.14561">OCaml Workshop paper</a>.</p></div></body></html>
