<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CodeGenerator (module_pbt.Lib.CodeGenerator)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">module_pbt</a> &#x00BB; <a href="../index.html">Lib</a> &#x00BB; CodeGenerator</nav><header class="odoc-preamble"><h1>Module <code><span>Lib.CodeGenerator</span></code></h1></header><div class="odoc-content"><p>Generic utility functions</p><div class="odoc-spec"><div class="spec value" id="val-write_doc" class="anchored"><a href="#val-write_doc" class="anchor"></a><code><span><span class="keyword">val</span> write_doc : <span><span class="xref-unresolved">Stdio</span>.Out_channel.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Writes a PPrint document to an Out_channel (eg. <code>stdout</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-spaced" class="anchored"><a href="#val-spaced" class="anchor"></a><code><span><span class="keyword">val</span> spaced : <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>spaced doc</code> adds a space on either side of the PPrint document <code>doc</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sBar" class="anchored"><a href="#val-sBar" class="anchor"></a><code><span><span class="keyword">val</span> sBar : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Aliases for PPrint documents for common OCaml symbols</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sArrow" class="anchored"><a href="#val-sArrow" class="anchor"></a><code><span><span class="keyword">val</span> sArrow : <span class="xref-unresolved">PPrint</span>.document</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-star2" class="anchored"><a href="#val-star2" class="anchor"></a><code><span><span class="keyword">val</span> star2 : <span class="xref-unresolved">PPrint</span>.document</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-comment" class="anchored"><a href="#val-comment" class="anchor"></a><code><span><span class="keyword">val</span> comment : <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Takes a PPrint document <code>body</code> and wraps it in the OCaml comment syntax, i.e. <code>comment body</code> is displayed as <code>(** body *)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-getModuleSigName" class="anchored"><a href="#val-getModuleSigName" class="anchor"></a><code><span><span class="keyword">val</span> getModuleSigName : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Given a filepath to a .ml/.mli file, retrieves the corresponding name of the top-level module signature (must be the same as the .ml/.mli file)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-replicate" class="anchored"><a href="#val-replicate" class="anchor"></a><code><span><span class="keyword">val</span> replicate : <span>n:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p><code>replicate n a</code> produces a list containing <code>n</code> copies of <code>a</code></p></div></div><p>Code generators for <code>Generated.ml</code>, the generated PBT code</p><div class="odoc-spec"><div class="spec value" id="val-imports" class="anchored"><a href="#val-imports" class="anchor"></a><code><span><span class="keyword">val</span> imports : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>imports filepath</code> prints out a PPrint document that imports the requisite modules for the PBT code. The <code>sigName, modName1, modName2</code> arguments are the names of the module signatures &amp; the two module implementations, which must be the same as their corresponding <code>.ml</code> files.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexpAnnotation" class="anchored"><a href="#val-sexpAnnotation" class="anchor"></a><code><span><span class="keyword">val</span> sexpAnnotation : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Document for printing the PPX annotation for S-Expr serialization (indented), followed by a newline</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArrowType" class="anchored"><a href="#val-isArrowType" class="anchor"></a><code><span><span class="keyword">val</span> isArrowType : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isArrowType v</code> returns true if the value declaration <code>v</code> has an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyIsArrow" class="anchored"><a href="#val-tyIsArrow" class="anchor"></a><code><span><span class="keyword">val</span> tyIsArrow : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>tyIsArrow ty</code> returns true if <code>ty</code> correspons to an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extractArgTypes" class="anchored"><a href="#val-extractArgTypes" class="anchor"></a><code><span><span class="keyword">val</span> extractArgTypes : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Extracts the argument types of functions defined in the module signature, and generates constructors for the <code>expr</code> ADT that take these types as type parameters</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exprADTDecl" class="anchored"><a href="#val-exprADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> exprADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>expr</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printConstructor" class="anchored"><a href="#val-printConstructor" class="anchor"></a><code><span><span class="keyword">val</span> printConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Helper function for printing out OCaml constructors (Wrapper for the <code>OCaml.variant</code> function in the <code>PPrint</code> library)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ty_of_string" class="anchored"><a href="#val-ty_of_string" class="anchor"></a><code><span><span class="keyword">val</span> ty_of_string : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a></span></code></div><div class="spec-doc"><p>Converts a string denoting a type to the equivalent <code>ty</code> ADT constructor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-varNameHelper" class="anchored"><a href="#val-varNameHelper" class="anchor"></a><code><span><span class="keyword">val</span> varNameHelper : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p><code>varNameHelper ty</code> returns an appropriate variable name corresponding to <code>ty</code>, eg. <code>varNameHelper Int = n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNamesSingleton" class="anchored"><a href="#val-genVarNamesSingleton" class="anchor"></a><code><span><span class="keyword">val</span> genVarNamesSingleton : <span>?prime:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Special case of <code>genVarNames</code> when we only have one argument type If <code>prime = true</code>, add a single quote to the end of the variable name</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNamesN" class="anchored"><a href="#val-genVarNamesN" class="anchor"></a><code><span><span class="keyword">val</span> genVarNamesN : <span>n:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates <code>n</code> unique variable names corresponding to a type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNames" class="anchored"><a href="#val-genVarNames" class="anchor"></a><code><span><span class="keyword">val</span> genVarNames : 
  <span>?prime:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Takes a list of argument types, and generates corresponding variable names which are unique for each element of the list eg. <code>genVarNames [Int, Int] = [n1, n2]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorName" class="anchored"><a href="#val-getExprConstructorName" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Fetches the <code>expr</code> constructor corresponding to a <code>val</code> declaration in a module</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructor" class="anchored"><a href="#val-getExprConstructor" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructor : 
  <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Fetches the constructor corresponding to a <code>val</code> declaration in the <code>expr</code> ADT, returning a pair of the form <code>(args, constructor applied to args)</code>, eg. <code>([&quot;x&quot;, &quot;e&quot;], !^ &quot;Mem(x,e)&quot;)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-extractReturnType" class="anchored"><a href="#val-extractReturnType" class="anchor"></a><code><span><span class="keyword">val</span> extractReturnType : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Extracts the return type of a function For non-arrow types, this function just extracts the type itself</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniqRetTypesInSig" class="anchored"><a href="#val-uniqRetTypesInSig" class="anchor"></a><code><span><span class="keyword">val</span> uniqRetTypesInSig : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Fetches the unique return types across the functions / values in a module signature</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTDecl" class="anchored"><a href="#val-tyADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> tyADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ty</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getFuncName" class="anchored"><a href="#val-getFuncName" class="anchor"></a><code><span><span class="keyword">val</span> getFuncName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Given a <code>val</code> declaration inside a module (eg. <code>val f : 'a -&gt; 'a</code>), returns the corresponding function name (eg. <code>M.f</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructorString" class="anchored"><a href="#val-valADTConstructorString" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructorString : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Like <code>valADTConstructor</code> (see below), but returns a string instead of a PPrint document</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructor" class="anchored"><a href="#val-valADTConstructor" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTConstructor ty</code> generates the constructor name for the <code>value</code> ADT corresponding to the type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTConstructors" class="anchored"><a href="#val-tyADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyADTConstructors : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates the list of constructor names for the <code>ty</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyAndValueADTConstructors" class="anchored"><a href="#val-tyAndValueADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyAndValueADTConstructors : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Returns an association list where each element is a constructor for the <code>ty</code> ADT &amp; its associated constructor for the <code>value</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTParam" class="anchored"><a href="#val-valADTParam" class="anchor"></a><code><span><span class="keyword">val</span> valADTParam : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTParam ty</code> generates the type param for the constructor <code>value</code> ADT corresponding to the type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTTypeDef" class="anchored"><a href="#val-valADTTypeDef" class="anchor"></a><code><span><span class="keyword">val</span> valADTTypeDef : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTTypeDef ty</code> generates both the constructor &amp; type parameter for the <code>value</code> ADT corresponding to the type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-valueADTDefn" class="anchored"><a href="#val-valueADTDefn" class="anchor"></a><code><span><span class="keyword">val</span> valueADTDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the <code>value</code> ADT definition (enclosed within the <code>ExprToImpl</code> functor)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpIsNeeded" class="anchored"><a href="#val-interpIsNeeded" class="anchor"></a><code><span><span class="keyword">val</span> interpIsNeeded : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p>Given an argument and its type, determines if we need to recursively call <code>interp</code> on the argument for the inner pattern match in <code>interp</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Applies a function pointwise on a pair</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map3" class="anchored"><a href="#val-map3" class="anchor"></a><code><span><span class="keyword">val</span> map3 : <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> * <span class="type-var">'b</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Applies a function pointwise on a triple</p></div></div><div class="odoc-spec"><div class="spec type" id="type-argPos" class="anchored"><a href="#type-argPos" class="anchor"></a><code><span><span class="keyword">type</span> argPos</span><span> = </span></code><table><tr id="type-argPos.Fst" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Fst" class="anchor"></a><code><span>| </span><span><span class="constructor">Fst</span></span></code></td></tr><tr id="type-argPos.Snd" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Snd" class="anchor"></a><code><span>| </span><span><span class="constructor">Snd</span></span></code></td></tr></table></div><div class="spec-doc"><p>Auxiliary data type for indicating the position of a non-<code>expr</code> argument to a function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-argPos_of_sexp" class="anchored"><a href="#val-argPos_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> argPos_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-argPos">argPos</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_argPos" class="anchored"><a href="#val-sexp_of_argPos" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_argPos : <span><a href="#type-argPos">argPos</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-interpOnce" class="anchored"><a href="#val-interpOnce" class="anchor"></a><code><span><span class="keyword">val</span> interpOnce : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?nonExprArg:<span><span>(string * <a href="#type-argPos">argPos</a>)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on one argument of type <code>expr</code> If <code>nonExprArg</code> is <code>Some</code> of some value, it is placed in the appropriate argument position during function application</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpTwice" class="anchored"><a href="#val-interpTwice" class="anchor"></a><code><span><span class="keyword">val</span> interpTwice : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on two arguments, both of type <code>expr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpExprPatternMatch" class="anchored"><a href="#val-interpExprPatternMatch" class="anchor"></a><code><span><span class="keyword">val</span> interpExprPatternMatch : 
  <span><span>(<a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the inner pattern match (<code>interp e</code>) in the <code>interp</code> function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpDefn" class="anchored"><a href="#val-interpDefn" class="anchor"></a><code><span><span class="keyword">val</span> interpDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>interp</code> function which evaluates <code>expr</code>s</p></div></div><div class="odoc-spec"><div class="spec value" id="val-functorDef" class="anchored"><a href="#val-functorDef" class="anchor"></a><code><span><span class="keyword">val</span> functorDef : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span>sigName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>functorName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ExprToImpl</code> functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-argGen" class="anchored"><a href="#val-argGen" class="anchor"></a><code><span><span class="keyword">val</span> argGen : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the code for a monadic bind of <code>arg</code> to a QuickCheck generator producing a value of type <code>ty</code>, where <code>ty</code> must be a non-arrow type (helper function called by <code>genExprPatternRHS</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatternRHS" class="anchored"><a href="#val-genExprPatternRHS" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatternRHS : 
  <span><span>(<span class="xref-unresolved">Base</span>.string
   * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
   * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
   * <span class="xref-unresolved">Base</span>.string
   * <span class="xref-unresolved">PPrint</span>.document)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span></span></code></div><div class="spec-doc"><p>Takes in the following arguments: <code>tyConstr</code>: constructor for the <code>ty</code> ADT representing the return type of a function <code>funcTy</code>: function type <code>args</code>: arguments passed to the <code>Expr</code> constructor <code>constr</code>: constructor for the <code>Expr</code> ADT <code>funcApp</code>: PPrint document containing the application of <code>constr</code> onto <code>args</code></p><p>Produces the RHS of the pattern matches in <code>gen_expr</code>, returning a tuple of the form <code>(tyConstr, (ty, patternMatchRHS, nameOfPatternMatch))</code></p><p>Eg. if <code>tyConstr = Bool</code>, <code>ty = Func2(Alpha, Expr, Bool)</code>, <code>constr = Mem</code> and <code>funcApp = Mem(x, e)</code>, then <code>genExprPatternRHS (tyConstr, ty, args, constr, funcApp)</code> produces the code &quot;let%bind arg = G.int in G.return @@ Mem(x, e)&quot;, where <code>G</code> = <code>Base_quickcheck.Generator</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorWithArgs" class="anchored"><a href="#val-getExprConstructorWithArgs" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorWithArgs : 
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string
  * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
  * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
  * <span class="xref-unresolved">Base</span>.string
  * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Takes in <code>tyConstr</code> (constructor for the <code>ty</code> ADT representing the return type of a function), <code>ty</code> (the type of the <code>Expr</code> construcctor), and <code>constr</code> (the string representation of an <code>Expr</code> constructor), and returns a 5-tuple of the form <code>(tyConstr, ty, constructorArgs, constructor, constructor applied to args)</code>, eg. <code>(Bool, Func2(Alpha, Expr, Bool), [&quot;x&quot;, &quot;e&quot;], &quot;Mem&quot;, !^ &quot;Mem(x,e)&quot;)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-curry3" class="anchored"><a href="#val-curry3" class="anchor"></a><code><span><span class="keyword">val</span> curry3 : <span><span>( <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span></span></code></div><div class="spec-doc"><p>Conversion between the curried/uncurried versions of an arity-3 function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uncurry3" class="anchored"><a href="#val-uncurry3" class="anchor"></a><code><span><span class="keyword">val</span> uncurry3 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatterns" class="anchored"><a href="#val-genExprPatterns" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatterns : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span>)</span> <span class="xref-unresolved">Base</span>.List.t</span></span></code></div><div class="spec-doc"><p>Returns an association list of constructors for the <code>ty</code> ADT where each element is the form <code>(&lt;constructor for the ty ADT&gt;, ty)</code></p></div></div><p>Generates the definition of the <code>gen_expr</code> Quickcheck generator for the <code>expr</code> datatype</p><div class="odoc-spec"><div class="spec value" id="val-genExprDef" class="anchored"><a href="#val-genExprDef" class="anchor"></a><code><span><span class="keyword">val</span> genExprDef : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-functorApp" class="anchored"><a href="#val-functorApp" class="anchor"></a><code><span><span class="keyword">val</span> functorApp : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces a PPrint document of an OCaml functor application, where <code>functorName</code> is the name of the functor, and <code>arg</code> is the name of the argument to the functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-implModuleBindings" class="anchored"><a href="#val-implModuleBindings" class="anchor"></a><code><span><span class="keyword">val</span> implModuleBindings : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the module bindings for the two module implemntations <code>I1, I2</code>, where <code>functorName</code> is the name of the functor that procduces the PBT test harness, and <code>modName1</code> &amp; <code>modName2</code> are the names of the two module implementaitons</p></div></div><p>Code generators for <code>compare_impls.ml</code>, the executable for comparing 2 modules</p><div class="odoc-spec"><div class="spec value" id="val-displayErrorDef" class="anchored"><a href="#val-displayErrorDef" class="anchor"></a><code><span><span class="keyword">val</span> displayErrorDef : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of a <code>displayError</code> helper function for displaying error messages when QuickCheck tests fail</p></div></div><div class="odoc-spec"><div class="spec value" id="val-executableImports" class="anchored"><a href="#val-executableImports" class="anchor"></a><code><span><span class="keyword">val</span> executableImports : 
  <span>pbtFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>execFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate requisite imports for the executable file, where <code>filepath</code> is the filepath to the executable file</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obsEquiv" class="anchored"><a href="#val-obsEquiv" class="anchor"></a><code><span><span class="keyword">val</span> obsEquiv : <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces Quickcheck code in the executable that tests two modules for observational equivalence based on <code>expr</code>s that return some <code>tyConstr</code> of type <code>ty</code>, and pattern matching on the equivalent <code>valConstr</code>s that they return</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compareImpls" class="anchored"><a href="#val-compareImpls" class="anchor"></a><code><span><span class="keyword">val</span> compareImpls : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate the executable code for testing observational equivalence of two modules</p></div></div></div></body></html>