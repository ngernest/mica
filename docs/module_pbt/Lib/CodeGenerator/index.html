<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CodeGenerator (module_pbt.Lib.CodeGenerator)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">module_pbt</a> &#x00BB; <a href="../index.html">Lib</a> &#x00BB; CodeGenerator</nav><header class="odoc-preamble"><h1>Module <code><span>Lib.CodeGenerator</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#functions-for-generating-pbt-code">Functions for generating PBT code</a></li><li><a href="#functions-for-generating-the-executable-for-comparing-two-modules">Functions for generating the executable for comparing two modules</a></li></ul></nav><div class="odoc-content"><p>This file contains the logic for generating PBT code from the AST of a parsed module signature. This file also calls some helper functions defined in the module <a href="../Utils/index.html"><code>Lib.Utils</code></a>.</p><h2 id="functions-for-generating-pbt-code"><a href="#functions-for-generating-pbt-code" class="anchor"></a>Functions for generating PBT code</h2><div class="odoc-spec"><div class="spec value" id="val-imports" class="anchored"><a href="#val-imports" class="anchor"></a><code><span><span class="keyword">val</span> imports : 
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>modName1:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>modName2:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>imports filepath</code> prints out a PPrint document that imports the requisite modules for the PBT code. The <code>sigName, modName1, modName2</code> arguments are the names of the module signatures &amp; the two module implementations, which must be the same as their corresponding <code>.ml</code> files.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sexpAnnotation" class="anchored"><a href="#val-sexpAnnotation" class="anchor"></a><code><span><span class="keyword">val</span> sexpAnnotation : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Document for printing the PPX annotation for S-Expr serialization (indented), followed by a newline</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArrowType" class="anchored"><a href="#val-isArrowType" class="anchor"></a><code><span><span class="keyword">val</span> isArrowType : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isArrowType v</code> returns true if the value declaration <code>v</code> has an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyIsArrow" class="anchored"><a href="#val-tyIsArrow" class="anchor"></a><code><span><span class="keyword">val</span> tyIsArrow : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>tyIsArrow ty</code> returns true if <code>ty</code> correspons to an arrow type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extractArgTypes" class="anchored"><a href="#val-extractArgTypes" class="anchor"></a><code><span><span class="keyword">val</span> extractArgTypes : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Extracts the argument types of functions defined in the module signature, and generates constructors for the <code>expr</code> ADT that take these types as type parameters</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exprADTDecl" class="anchored"><a href="#val-exprADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> exprADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>expr</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printConstructor" class="anchored"><a href="#val-printConstructor" class="anchor"></a><code><span><span class="keyword">val</span> printConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Helper function for printing out OCaml constructors (Wrapper for the <code>OCaml.variant</code> function in the <code>PPrint</code> library)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ty_of_string" class="anchored"><a href="#val-ty_of_string" class="anchor"></a><code><span><span class="keyword">val</span> ty_of_string : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a></span></code></div><div class="spec-doc"><p>Converts a string denoting a type to the equivalent <code>ty</code> ADT constructor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-varNameHelper" class="anchored"><a href="#val-varNameHelper" class="anchor"></a><code><span><span class="keyword">val</span> varNameHelper : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p><code>varNameHelper ty</code> returns an appropriate variable name corresponding to <code>ty</code>, eg. <code>varNameHelper Int = n</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNamesSingleton" class="anchored"><a href="#val-genVarNamesSingleton" class="anchor"></a><code><span><span class="keyword">val</span> genVarNamesSingleton : <span>?prime:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Special case of <code>genVarNames</code> when we only have one argument type. If <code>prime = true</code>, add a single quote to the end of the variable name</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNamesN" class="anchored"><a href="#val-genVarNamesN" class="anchor"></a><code><span><span class="keyword">val</span> genVarNamesN : <span>n:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates <code>n</code> unique variable names corresponding to a type <code>ty</code>. For example, <code>genVarNamesN 3 Int</code> produces <code>[&quot;n1&quot;; &quot;n2&quot;; &quot;n3&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-genVarNames" class="anchored"><a href="#val-genVarNames" class="anchor"></a><code><span><span class="keyword">val</span> genVarNames : 
  <span>?prime:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Takes a list of argument types, and generates corresponding variable names which are unique for each element of the list eg. <code>genVarNames [Int; Int; Char] = [n1; n2; c]</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorName" class="anchored"><a href="#val-getExprConstructorName" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Fetches the <code>expr</code> constructor corresponding to a <code>val</code> declaration in a module</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructor" class="anchored"><a href="#val-getExprConstructor" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructor : 
  <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span> * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Fetches the constructor corresponding to a <code>val</code> declaration in the <code>expr</code> ADT, returning a pair of the form <code>(args, constructor applied to args)</code>, eg. <code>([&quot;x&quot;, &quot;e&quot;], !^ &quot;Mem(x,e)&quot;)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-extractReturnType" class="anchored"><a href="#val-extractReturnType" class="anchor"></a><code><span><span class="keyword">val</span> extractReturnType : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Extracts the return type of a function. For non-arrow types, this function just extracts the type itself</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uniqRetTypesInSig" class="anchored"><a href="#val-uniqRetTypesInSig" class="anchor"></a><code><span><span class="keyword">val</span> uniqRetTypesInSig : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Fetches the unique return types across the functions / values in a module signature</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTDecl" class="anchored"><a href="#val-tyADTDecl" class="anchor"></a><code><span><span class="keyword">val</span> tyADTDecl : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ty</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getFuncName" class="anchored"><a href="#val-getFuncName" class="anchor"></a><code><span><span class="keyword">val</span> getFuncName : <span><a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Given a <code>val</code> declaration inside a module (eg. <code>val f : 'a -&gt; 'a</code>), returns the corresponding function name (eg. <code>M.f</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructorString" class="anchored"><a href="#val-valADTConstructorString" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructorString : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Like <code>valADTConstructor</code> (see below), but returns a string instead of a PPrint document</p></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTConstructor" class="anchored"><a href="#val-valADTConstructor" class="anchor"></a><code><span><span class="keyword">val</span> valADTConstructor : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTConstructor ty</code> generates the constructor name for the <code>value</code> ADT corresponding to the type <code>ty</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyADTConstructors" class="anchored"><a href="#val-tyADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyADTConstructors : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Generates the list of constructor names for the <code>ty</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tyAndValADTConstructors" class="anchored"><a href="#val-tyAndValADTConstructors" class="anchor"></a><code><span><span class="keyword">val</span> tyAndValADTConstructors : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="xref-unresolved">Base</span>.list</span></span></code></div><div class="spec-doc"><p>Returns an association list where each element is a constructor for the <code>ty</code> ADT &amp; its associated constructor for the <code>value</code> ADT</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiateT" class="anchored"><a href="#val-instantiateT" class="anchor"></a><code><span><span class="keyword">val</span> instantiateT : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div><div class="spec-doc"><p>Takes <code>s</code>, a string reprentation of a type, and instantiates the abstract type <code>t</code> to <code>int M.t</code> where <code>M</code> is some module defined elsewhere. \n</p><ul><li>Example: <code>instantiate &quot;toption&quot; = &quot;int M.t option&quot;</code></li><li>If <code>s</code> doesn't contain the prefix <code>&quot;t&quot;</code>, <code>s</code> is left unchanged</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-addSpaceToTyStr" class="anchored"><a href="#val-addSpaceToTyStr" class="anchor"></a><code><span><span class="keyword">val</span> addSpaceToTyStr : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div><div class="spec-doc"><p>Takes <code>s</code>, a string reprentation of a type, and adds a space to <code>s</code> if <code>s</code> represents a parameterized type.</p><ul><li>Example: <code>addSpaceToTyStr &quot;intoption&quot; = &quot;int option&quot;</code></li><li>If <code>s</code> doesn't contain the prefix <code>&quot;t&quot;</code>, <code>s</code> is left unchanged</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTParam" class="anchored"><a href="#val-valADTParam" class="anchor"></a><code><span><span class="keyword">val</span> valADTParam : 
  <span>moduleAbsTy:<a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTParam moduleAbsTy ty</code> generates the type param for the constructor <code>value</code> ADT corresponding to the type <code>ty</code></p><ul><li>The auxiliary argument <code>moduleAbsTy</code> refers to the abstract type contained within the module signature, e.g. <code>M.t</code></li><li>If the module's abstract type <code>M.t</code> is polymorphic (i.e. <code>'a M.t</code>), we instantiate <code>'a</code> with <code>int</code>, otherwise we leave the abstract type monomorphic (i.e. just <code>M.t</code>)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTTypeDef" class="anchored"><a href="#val-valADTTypeDef" class="anchor"></a><code><span><span class="keyword">val</span> valADTTypeDef : 
  <span>moduleAbsTy:<a href="../ParserTypes/index.html#type-abstractType">ParserTypes.abstractType</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>valADTTypeDef moduleAbsTy ty</code> generates both the constructor &amp; type parameter for the <code>value</code> ADT corresponding to the type <code>ty</code></p><ul><li>The auxiliary argument <code>moduleAbsTy</code> is the abstract type defined in the module, which is used to determine if the abstract type needs to be instantiated with a concrete type (this logic is handled in <code>valADTParam</code>)</li><li>Note: This function is a helper function called by <code>valADTDefn</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-valADTDefn" class="anchored"><a href="#val-valADTDefn" class="anchor"></a><code><span><span class="keyword">val</span> valADTDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the <code>value</code> ADT definition that is contained within the module returned by the <code>ExprToImpl</code> functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpIsNeeded" class="anchored"><a href="#val-interpIsNeeded" class="anchor"></a><code><span><span class="keyword">val</span> interpIsNeeded : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p>Given an argument and its type, determines if we need to recursively call <code>interp</code> on the argument for the inner pattern match in <code>interp</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-argPos" class="anchored"><a href="#type-argPos" class="anchor"></a><code><span><span class="keyword">type</span> argPos</span><span> = </span></code><table><tr id="type-argPos.Fst" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Fst" class="anchor"></a><code><span>| </span><span><span class="constructor">Fst</span></span></code></td></tr><tr id="type-argPos.Snd" class="anchored"><td class="def variant constructor"><a href="#type-argPos.Snd" class="anchor"></a><code><span>| </span><span><span class="constructor">Snd</span></span></code></td></tr></table></div><div class="spec-doc"><p>Auxiliary data type for indicating the position of a non-<code>expr</code> argument to a function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-argPos_of_sexp" class="anchored"><a href="#val-argPos_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> argPos_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-argPos">argPos</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sexp_of_argPos" class="anchored"><a href="#val-sexp_of_argPos" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_argPos : <span><a href="#type-argPos">argPos</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-interpOnce" class="anchored"><a href="#val-interpOnce" class="anchor"></a><code><span><span class="keyword">val</span> interpOnce : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?nonExprArg:<span><span>(string * <a href="#type-argPos">argPos</a>)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on one argument of type <code>expr</code> If <code>nonExprArg</code> is <code>Some</code> of some value, it is placed in the appropriate argument position during function application</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpTwice" class="anchored"><a href="#val-interpTwice" class="anchor"></a><code><span><span class="keyword">val</span> interpTwice : 
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">PPrint</span>.document <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ident">ParserTypes.ident</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Pattern matches <code>interp</code> on two arguments, both of type <code>expr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpExprPatternMatch" class="anchored"><a href="#val-interpExprPatternMatch" class="anchor"></a><code><span><span class="keyword">val</span> interpExprPatternMatch : 
  <span><span>(<a href="../ParserTypes/index.html#type-valDecl">ParserTypes.valDecl</a> * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the inner pattern match (<code>interp e</code>) in the <code>interp</code> function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpDefn" class="anchored"><a href="#val-interpDefn" class="anchor"></a><code><span><span class="keyword">val</span> interpDefn : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>interp</code> function which evaluates <code>expr</code>s</p></div></div><div class="odoc-spec"><div class="spec value" id="val-functorDef" class="anchored"><a href="#val-functorDef" class="anchor"></a><code><span><span class="keyword">val</span> functorDef : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span>sigName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>functorName:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of the <code>ExprToImpl</code> functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getGenerator" class="anchored"><a href="#val-getGenerator" class="anchor"></a><code><span><span class="keyword">val</span> getGenerator : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p><code>getGenerator ty</code> takes in a type <code>ty</code> and produces a PPrint document containing the corresponding QuickCheck generator for that type.</p><ul><li>This is a helper function called by <code>argGen</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-argGen" class="anchored"><a href="#val-argGen" class="anchor"></a><code><span><span class="keyword">val</span> argGen : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the code for a monadic bind of <code>arg</code> to a QuickCheck generator producing a value of type <code>ty</code>, where <code>ty</code> must be a non-arrow type.</p><ul><li>This is a helper function called by <code>genExprPatternRHS</code>)</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatternRHS" class="anchored"><a href="#val-genExprPatternRHS" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatternRHS : 
  <span><span>(<span class="xref-unresolved">Base</span>.string
   * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
   * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
   * <span class="xref-unresolved">Base</span>.string
   * <span class="xref-unresolved">PPrint</span>.document)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span></span></code></div><div class="spec-doc"><p>Takes in the following arguments: <code>tyConstr</code>: constructor for the <code>ty</code> ADT representing the return type of a function <code>funcTy</code>: function type <code>args</code>: arguments passed to the <code>Expr</code> constructor <code>constr</code>: constructor for the <code>Expr</code> ADT <code>funcApp</code>: PPrint document containing the application of <code>constr</code> onto <code>args</code></p><p>Produces the RHS of the pattern matches in <code>gen_expr</code>, returning a tuple of the form <code>(tyConstr, (ty, patternMatchRHS, nameOfPatternMatch))</code></p><p>For example, if:</p><ul><li><code>tyConstr = Bool</code></li><li><code>ty = Func2(Alpha, Expr, Bool)</code></li><li><code>constr = Mem</code></li><li><p><code>funcApp = Mem(x, e)</code> then <code>genExprPatternRHS (tyConstr, ty, args, constr, funcApp)</code> produces the code</p><pre><code>let%bind arg = G.int in G.return @@ Mem(x, e)</code></pre><p>where <code>G</code> = <code>Base_quickcheck.Generator</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-getExprConstructorWithArgs" class="anchored"><a href="#val-getExprConstructorWithArgs" class="anchor"></a><code><span><span class="keyword">val</span> getExprConstructorWithArgs : 
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string
  * <a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a>
  * <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.list</span>
  * <span class="xref-unresolved">Base</span>.string
  * <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Takes in <code>tyConstr</code> (constructor for the <code>ty</code> ADT representing the return type of a function), <code>ty</code> (the type of the <code>Expr</code> construcctor), and <code>constr</code> (the string representation of an <code>Expr</code> constructor), and returns a 5-tuple of the form <code>(tyConstr, ty, constructorArgs, constructor, constructor applied to args)</code>, eg. <code>(Bool, Func2(Alpha, Expr, Bool), [&quot;x&quot;, &quot;e&quot;], &quot;Mem&quot;, !^ &quot;Mem(x,e)&quot;)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-genExprPatterns" class="anchored"><a href="#val-genExprPatterns" class="anchor"></a><code><span><span class="keyword">val</span> genExprPatterns : 
  <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Base</span>.string * <span>(<a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> * <span class="xref-unresolved">PPrint</span>.document * <span class="xref-unresolved">Base</span>.string)</span>)</span> <span class="xref-unresolved">Base</span>.List.t</span></span></code></div><div class="spec-doc"><p>Returns an association list of constructors for the <code>ty</code> ADT where each element is the form <code>(&lt;constructor for the ty ADT&gt;, ty)</code></p></div></div><p>Generates the definition of the <code>gen_expr</code> Quickcheck generator for the <code>expr</code> datatype</p><div class="odoc-spec"><div class="spec value" id="val-genExprDef" class="anchored"><a href="#val-genExprDef" class="anchor"></a><code><span><span class="keyword">val</span> genExprDef : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-functorApp" class="anchored"><a href="#val-functorApp" class="anchor"></a><code><span><span class="keyword">val</span> functorApp : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces a PPrint document of an OCaml functor application, where <code>functorName</code> is the name of the functor, and <code>arg</code> is the name of the argument to the functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-implModuleBindings" class="anchored"><a href="#val-implModuleBindings" class="anchor"></a><code><span><span class="keyword">val</span> implModuleBindings : 
  <span>functorName:<a href="../ParserTypes/index.html#type-moduleName">ParserTypes.moduleName</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces the module bindings for the two module implemntations <code>I1, I2</code>, where <code>functorName</code> is the name of the functor that procduces the PBT test harness, and <code>modName1</code> &amp; <code>modName2</code> are the names of the two module implementaitons</p></div></div><h2 id="functions-for-generating-the-executable-for-comparing-two-modules"><a href="#functions-for-generating-the-executable-for-comparing-two-modules" class="anchor"></a>Functions for generating the executable for comparing two modules</h2><div class="odoc-spec"><div class="spec value" id="val-displayErrorDef" class="anchored"><a href="#val-displayErrorDef" class="anchor"></a><code><span><span class="keyword">val</span> displayErrorDef : <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generates the definition of a <code>displayError</code> helper function for displaying error messages when QuickCheck tests fail</p></div></div><div class="odoc-spec"><div class="spec value" id="val-executableImports" class="anchored"><a href="#val-executableImports" class="anchor"></a><code><span><span class="keyword">val</span> executableImports : 
  <span>pbtFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span>execFilePath:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate requisite imports for the executable file, where <code>filepath</code> is the filepath to the executable file</p></div></div><div class="odoc-spec"><div class="spec value" id="val-obsEquiv" class="anchored"><a href="#val-obsEquiv" class="anchor"></a><code><span><span class="keyword">val</span> obsEquiv : <span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.string)</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Produces Quickcheck code in the executable that tests two modules for observational equivalence based on <code>expr</code>s that return some <code>tyConstr</code> of type <code>ty</code>, and pattern matching on the equivalent <code>valConstr</code>s that they return</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isExcludedType" class="anchored"><a href="#val-isExcludedType" class="anchor"></a><code><span><span class="keyword">val</span> isExcludedType : <span><a href="../ParserTypes/index.html#type-ty">ParserTypes.ty</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div><div class="spec-doc"><p><code>isExcludedType ty</code> returns true if the type <code>ty</code> is a return type to be excluded from consideration when testing for <i>observational equivalence</i>.</p><ul><li>For example, expressions returning abstract types <code>T</code> and <code>AlphaT</code> are excluded when we check if two modules for observational equivalence, because these abstract types may be instantiated differently in the two modules.</li><li>For instance, one module could instantiate <code>'a t</code> to be <code>'a list</code>, while the other instantiates <code>'a t</code> to be <code>'a tree</code>.</li><li>Note that arrow types are not considered by this function.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-compareImpls" class="anchored"><a href="#val-compareImpls" class="anchor"></a><code><span><span class="keyword">val</span> compareImpls : <span><a href="../ParserTypes/index.html#type-moduleSig">ParserTypes.moduleSig</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">PPrint</span>.document</span></code></div><div class="spec-doc"><p>Generate the executable code for testing observational equivalence of two modules</p></div></div></div></body></html>