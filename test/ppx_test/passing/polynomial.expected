module type PolyInterface  =
  sig
    type t
    val zero : t
    val one : t
    val power : int -> int -> int
    val monomial : int -> int -> t
    val add : t -> t -> t
    val mult : t -> t -> t
    val create : (int * int) list -> t
    val eval : t -> int -> int
    val equal : t -> t -> bool
  end[@@deriving (mica_types, mica)]
include
  struct
    [@@@ocaml.warning "-60"]
    type expr =
      | Zero 
      | One 
      | Power of int * int 
      | Monomial of int * int 
      | Add of expr * expr 
      | Mult of expr * expr 
      | Create of (int * int) list 
      | Eval of expr * int 
      | Equal of expr * expr 
    type ty =
      | Bool 
      | Int 
      | T 
    let gen_expr ty =
      let open Core.Quickcheck.Generator in
        let open Let_syntax in
          [%bind let x = small_non_negative_int in return x]
    module TestHarness(M:PolyInterface) =
      struct
        include M
        type value =
          | ValBool of bool 
          | ValInt of int 
          | ValT of t 
        let rec interp e =
          match e with
          | Zero -> ValT M.zero
          | One -> ValT M.one
          | Power (int__001_, int__002_) ->
              ValInt (M.power int__001_ int__002_)
          | Monomial (int__003_, int__004_) ->
              ValT (M.monomial int__003_ int__004_)
          | Add (expr__005_, expr__006_) ->
              (match ((interp expr__005_), (interp expr__006_)) with
               | (ValT expr__005_', ValT expr__006_') ->
                   ValT (M.add expr__005_' expr__006_')
               | _ -> failwith "impossible: n-ary constructor")
          | Mult (expr__007_, expr__008_) ->
              (match ((interp expr__007_), (interp expr__008_)) with
               | (ValT expr__007_', ValT expr__008_') ->
                   ValT (M.mult expr__007_' expr__008_')
               | _ -> failwith "impossible: n-ary constructor")
          | Create intIntProductList__009_ ->
              ValT (M.create intIntProductList__009_)
          | Eval (expr__010_, int__011_) ->
              (match interp expr__010_ with
               | ValT expr__010_' -> ValInt (M.eval expr__010_' int__011_)
               | _ -> failwith "impossible: n-ary constructor")
          | Equal (expr__012_, expr__013_) ->
              (match ((interp expr__012_), (interp expr__013_)) with
               | (ValT expr__012_', ValT expr__013_') ->
                   ValBool (M.equal expr__012_' expr__013_')
               | _ -> failwith "impossible: n-ary constructor")
      end
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
