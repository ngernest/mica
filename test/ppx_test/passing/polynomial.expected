module type PolyInterface  =
  sig
    type t
    val zero : t
    val one : t
    val power : int -> int -> int
    val monomial : int -> int -> t
    val add : t -> t -> t
    val mult : t -> t -> t
    val create : (int * int) list -> t
    val eval : t -> int -> int
    val equal : t -> t -> bool
  end[@@deriving (mica_types, mica)]
include
  struct
    [@@@ocaml.warning "-60"]
    type expr =
      | Zero 
      | One 
      | Power of int * int 
      | Monomial of int * int 
      | Add of expr * expr 
      | Mult of expr * expr 
      | Create of (int * int) list 
      | Eval of expr * int 
      | Equal of expr * expr 
    type ty =
      | Bool 
      | Int 
      | T 
    let gen_expr ty =
      let open Core in
        let open Quickcheck.Generator in
          let open Let_syntax in
            size >>=
              (fun x ->
                 match ty with
                 | Bool -> of_list [Equal (expr__012_, expr__013_)]
                 | Int ->
                     of_list
                       [Power (int__001_, int__002_);
                       Eval (expr__010_, int__011_)]
                 | T ->
                     of_list
                       [Zero ();
                       One ();
                       Monomial (int__003_, int__004_);
                       Add (expr__005_, expr__006_);
                       Mult (expr__007_, expr__008_);
                       Create intIntProductList__009_])
    module TestHarness(M:PolyInterface) =
      struct
        include M
        type value =
          | ValBool of bool 
          | ValInt of int 
          | ValT of t 
        let rec interp e =
          match e with
          | Zero -> ValT M.zero
          | One -> ValT M.one
          | Power (int__014_, int__015_) ->
              ValInt (M.power int__014_ int__015_)
          | Monomial (int__016_, int__017_) ->
              ValT (M.monomial int__016_ int__017_)
          | Add (expr__018_, expr__019_) ->
              (match ((interp expr__018_), (interp expr__019_)) with
               | (ValT expr__018_', ValT expr__019_') ->
                   ValT (M.add expr__018_' expr__019_')
               | _ -> failwith "impossible: n-ary constructor")
          | Mult (expr__020_, expr__021_) ->
              (match ((interp expr__020_), (interp expr__021_)) with
               | (ValT expr__020_', ValT expr__021_') ->
                   ValT (M.mult expr__020_' expr__021_')
               | _ -> failwith "impossible: n-ary constructor")
          | Create intIntProductList__022_ ->
              ValT (M.create intIntProductList__022_)
          | Eval (expr__023_, int__024_) ->
              (match interp expr__023_ with
               | ValT expr__023_' -> ValInt (M.eval expr__023_' int__024_)
               | _ -> failwith "impossible: n-ary constructor")
          | Equal (expr__025_, expr__026_) ->
              (match ((interp expr__025_), (interp expr__026_)) with
               | (ValT expr__025_', ValT expr__026_') ->
                   ValBool (M.equal expr__025_' expr__026_')
               | _ -> failwith "impossible: n-ary constructor")
      end
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
